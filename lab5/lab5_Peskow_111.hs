{-(1). Определите следующие функции с использованием функций высшего порядка:

(1) Функция вычисления арифметического среднего элементов
списка вещественных чисел с использованием функции
foldr. Функция должна осуществлять только один проход
по списку.-}

len :: [Float] -> Float
len [] = 0
len (x:xs) = 1 + len xs

arifMid :: [Float] -> Float
arifMid x = (foldr (+) 0 x ) / len x 

{-(2) Функция, вычисляющая скалярное произведение двух списков
(используйте функции foldr и zipWith).-}

scal9r :: [Float] -> [Float] -> Float
scal9r x y =  foldr (+) 0.0 (zipWith (*) x y) -- сумма произведений

{-(3)Функция countEven, возвращающая количество четных элементов в списке.-}

filter2 :: (a -> Bool) -> [a] -> Int
filter2 p [] = 0
filter2 p (x:xs) | p x = 1 + filter2 p xs
                 | otherwise = filter2 p xs

countEven = filter2 even -- каррирование

{-(4) Функция quicksort, осуществляющая быструю сортировку
списка по следующему рекурсивному алгоритму. Для того,
чтобы отсортировать список xs, из него выбирается первый
элемент (обозначим его x). Остальной список делится на две
части: список, состоящий из элементов xs, меньших x и список элементов, больших x. Эти списки сортируются (здесь
проявляется рекурсия, поскольку они сортируются этим же
алгоритмов), а затем из них составляется результирующий
список вида as ++ [x] ++ bs, где as и bs — отсортированные списки меньших и больших элементов соответственно.-}

filter3 :: (a -> a -> Bool) -> a -> [a] -> [a]
filter3 p t [] = []
filter3 p t (x:xs) | p t x = x : filter3 p t xs
                   | otherwise = filter3 p t xs 

up :: Int -> [Int] -> [Int]
up x xs = filter3 (<=) x xs 
down :: Int -> [Int] -> [Int]
down x xs = filter3 (>) x xs

quicksort :: [Int] -> [Int]
quicksort [] = []
quicksort (x:xs) = (quicksort ( down x xs )) ++ [x] ++ (quicksort ( up x xs ))

{-(5) Определенная в предыдущем пункте функция quicksort
сортирует список в порядке возрастания. Обобщите ее: пусть
она принимает еще один аргумент — функцию сравнения типа
a -> a -> Bool и сортирует список в соответствие с нею.-}


quickSORT :: (Int -> Int -> Bool) -> [Int] -> [Int]
quickSORT p [] = []
quickSORT p (x:xs) = (quickSORT (p) (filter3 (\x y -> (p) x y) x xs)) ++ [x] ++ (quickSORT (p) (filter3 (\y x -> (p) x y) x xs))
{-
*Main> quickSORT (\x y -> x > y) [1,3,5,7,2]
[1,2,3,5,7]
*Main> quickSORT (\x y -> x > y) [1,3,5,7,2,3]
[1,2,3,5,7]
*Main> quickSORT (\x y -> x >= y) [1,3,5,7,2,3]
[1,2,3,3,3,5,7]
*Main> quickSORT (\x y -> x <= y) [1,3,5,7,2,3]
[7,5,3,3,3,2,1]
-}



